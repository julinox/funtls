package tlssl

import (
	"encoding/binary"
	"fmt"

	"tlesio/tlssl/extensions"

	"github.com/sirupsen/logrus"
)

// ClientHello message structure in TLS 1.2
// | Field            | Size (bytes) | Description                                              |
// |------------------|--------------|----------------------------------------------------------|
// | Version          | 2 bytes      | TLS version (e.g., 0x0303 for TLS 1.2)                   |
// | Random           | 32 bytes     | Random number generated by the client                    |
// | Session ID       | Variable     | Client session ID, can be empty                          |
// | Cipher Suites    | Variable     | List of cipher suites supported by the client            |
// | Compression Methods | Variable   | Compression methods supported by the client             |
// | Extensions       | Variable     | Extensions (optional)                                    |
// |--------------------------------------------------------------------------------------------|

var (
	offsetVersion         uint32 = 2
	offsetRandom          uint32 = 32
	offsetSessionIdLen    uint32 = 1
	offsetCipherSuitesLen uint32 = 2
)

// Compresion Methods will be ignored
// Using byte arrays instead of "uint*" to avoid endianess issues
type clientHelloMsg struct {
	version      [2]byte
	random       [32]byte
	sessionId    []byte
	cipherSuites []uint16
	//extensions   []
}

type clientHello struct {
	lg       *logrus.Logger
	helloMsg clientHelloMsg
}

func newClientHello(buffer []byte, lg *logrus.Logger) *clientHelloMsg {

	var err error
	var aux uint32
	var ch clientHello
	var offset uint32 = 0

	if lg == nil {
		return nil
	}

	if buffer == nil || len(buffer) < 38 {
		lg.Error("ClientHello buffer is nil or too small")
		return nil
	}

	ch.lg = lg
	offset += ch.parseVersion(buffer)
	offset += ch.parseRandom(buffer[offset:])
	aux, err = ch.parseSessionID(buffer[offset:])
	if err != nil {
		lg.Error(err)
		return nil
	}

	offset += aux
	aux, err = ch.parseCipherSuites(buffer[offset:])
	if err != nil {
		lg.Error(err)
		return nil
	}

	offset += aux
	// Skip parsing Compression Methods
	if len(buffer) < int(offset+1) {
		lg.Error("ClientHello buffer is too small to contain Compression Methods length")
		return nil
	}
	compressionMethodsLen := uint32(buffer[offset])
	offset += 1 + compressionMethodsLen
	ch.parseExtensions(buffer[offset:])
	return nil
}

func (ch *clientHello) parseVersion(buffer []byte) uint32 {

	ch.helloMsg.version = [2]byte{buffer[0], buffer[1]}
	ch.lg.Trace("Field[Version]: ", prettyPrint(ch.helloMsg.version[:]))
	return offsetVersion
}

func (ch *clientHello) parseRandom(buffer []byte) uint32 {

	copy(ch.helloMsg.random[:], buffer[:offsetRandom])
	ch.lg.Trace("Field[Random]: ", prettyPrint(ch.helloMsg.random[:]))
	return offsetRandom
}

func (ch *clientHello) parseSessionID(buffer []byte) (uint32, error) {

	if len(buffer) < 1 {
		return 0, fmt.Errorf("sessionID field is too small")
	}

	fieldLen := uint32(buffer[0])
	offset := uint32(offsetSessionIdLen)
	if len(buffer) < int(offset+fieldLen) {
		return 0, fmt.Errorf("sessionID field is too small")
	}

	ch.helloMsg.sessionId = make([]byte, fieldLen)
	copy(ch.helloMsg.sessionId, buffer[offset:offset+fieldLen])
	ch.lg.Trace("Field[SessionID]: ", prettyPrint(ch.helloMsg.sessionId))
	return offset + fieldLen, nil
}

func (ch *clientHello) parseCipherSuites(buffer []byte) (uint32, error) {

	offset := uint32(offsetCipherSuitesLen)
	fieldLen := binary.BigEndian.Uint16(buffer[:2])
	if len(buffer) < int(fieldLen) {
		return 0, fmt.Errorf("CipherSuites field is too small")
	}

	if fieldLen%2 != 0 {
		return 0, fmt.Errorf("CipherSuites field is not a multiple of 2")
	}

	fl := fieldLen / 2
	ch.helloMsg.cipherSuites = make([]uint16, fl)
	for i := uint16(0); i < fl; i++ {
		ch.helloMsg.cipherSuites[i] = binary.BigEndian.Uint16(buffer[offset : offset+2])
		offset += 2
	}

	ch.lg.Trace("Field[CipherSuites]: ", printCipherSuiteNames(ch.helloMsg.cipherSuites))
	return offset, nil
}

func (ch *clientHello) parseExtensions(buffer []byte) {

	// Parsing only supported extensions
	if len(buffer) < 2 {
		return
	}

	offset := 0
	extLen := binary.BigEndian.Uint16(buffer[:2])
	if len(buffer) < int(extLen) {
		return
	}

	offset += 2
	for offset < int(extLen) {
		extt := binary.BigEndian.Uint16(buffer[offset : offset+2])
		exttLen := binary.BigEndian.Uint16(buffer[offset+2 : offset+4])
		// Points
		offset += 2 + 2

		fmt.Printf("Extension Type/Len: %v/%v\n", extensions.ExtensionName[extt], exttLen)
		offset += int(exttLen)
	}
}

// Print a byte array in a 'pretty' format
func prettyPrint(buffer []byte) string {

	var pretty string

	for i, b := range buffer {
		pretty += fmt.Sprintf("%02x ", b)
		if (i+1)%16 == 0 && i+1 != len(buffer) {
			pretty += "\n"
		}
	}

	return pretty
}
