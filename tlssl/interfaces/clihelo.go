package interfaces

import (
	"encoding/binary"
	"fmt"
	syst "tlesio/systema"
	ex "tlesio/tlssl/extensions"
	mx "tlesio/tlssl/modulos"

	"github.com/sirupsen/logrus"
)

// ClientHello message structure in TLS 1.2
// | Field            | Size (bytes) | Description                                              |
// |------------------|--------------|----------------------------------------------------------|
// | Version          | 2 bytes      | TLS version (e.g., 0x0303 for TLS 1.2)                   |
// | Random           | 32 bytes     | Random number generated by the client                    |
// | Session ID       | Variable     | Client session ID, can be empty                          |
// | Cipher Suites    | Variable     | List of cipher suites supported by the client            |
// | Compression Methods | Variable   | Compression methods supported by the client             |
// | Extensions       | Variable     | Extensions (optional)                                    |
// |--------------------------------------------------------------------------------------------|
// Compresion Methods will be ignored

var (
	offsetVersion         uint32 = 2
	offsetRandom          uint32 = 32
	offsetSessionIdLen    uint32 = 1
	offsetCipherSuitesLen uint32 = 2
)

type CliHello interface {
	Name() string
	Handle([]byte) (*MsgHelloCli, error)
}

type MsgHelloCli struct {
	Version      [2]byte
	Random       [32]byte
	SessionId    []byte
	CipherSuites []uint16
	Extensions   map[uint16]interface{} //ExtensionType -> ExtensionData
}

type xCliHello struct {
	name     string
	mods     *mx.ModuloZ
	exts     *ex.Extensions
	helloMsg *MsgHelloCli
	lg       *logrus.Logger
}

func NewIfCliHello(params *IfaceParams) CliHello {

	if params == nil || params.Lg == nil ||
		params.Mx == nil || params.Ex == nil {
		return nil
	}

	return &xCliHello{
		name: "CliHello",
		lg:   params.Lg,
		mods: params.Mx,
		exts: params.Ex,
	}
}

func (rox *xCliHello) Handle(buffer []byte) (*MsgHelloCli, error) {

	var err error
	var aux uint32
	var offset uint32 = 0

	if buffer == nil || len(buffer) < 38 {
		return nil, fmt.Errorf("ClientHello buffer is nil or too small")
	}

	rox.helloMsg = &MsgHelloCli{}
	offset += rox.parseVersion(buffer)
	offset += rox.parseRandom(buffer[offset:])
	aux, err = rox.parseSessionID(buffer[offset:])
	if err != nil {
		return nil, err
	}

	offset += aux
	aux, err = rox.parseCipherSuites(buffer[offset:])
	if err != nil {
		return nil, err
	}

	offset += aux
	// Skip parsing Compression Methods
	if len(buffer) < int(offset+1) {
		return nil, fmt.Errorf("buffer too small in Compression Methods len")
	}

	compressionMethodsLen := uint32(buffer[offset])
	offset += 1 + compressionMethodsLen
	rox.helloMsg.Extensions = make(map[uint16]interface{})
	rox.parseExtensions(buffer[offset:])
	return rox.helloMsg, nil
}

func (rox *xCliHello) Name() string {
	return rox.name
}

func (rox *xCliHello) parseVersion(buffer []byte) uint32 {

	rox.helloMsg.Version = [2]byte{buffer[0], buffer[1]}
	rox.lg.Trace("Field[Version]: ",
		syst.PrettyPrintBytes(rox.helloMsg.Version[:]))
	return offsetVersion
}

func (rox *xCliHello) parseRandom(buffer []byte) uint32 {

	copy(rox.helloMsg.Random[:], buffer[:offsetRandom])
	rox.lg.Trace("Field[Random]: ",
		syst.PrettyPrintBytes(rox.helloMsg.Random[:]))
	return offsetRandom
}

func (rox *xCliHello) parseSessionID(buffer []byte) (uint32, error) {

	if len(buffer) < 1 {
		return 0, fmt.Errorf("sessionID field is too small")
	}

	fieldLen := uint32(buffer[0])
	offset := uint32(offsetSessionIdLen)
	if len(buffer) < int(offset+fieldLen) {
		return 0, fmt.Errorf("sessionID field is too small")
	}

	rox.helloMsg.SessionId = make([]byte, fieldLen)
	copy(rox.helloMsg.SessionId, buffer[offset:offset+fieldLen])
	rox.lg.Trace("Field[SessionID]: ",
		syst.PrettyPrintBytes(rox.helloMsg.SessionId))
	return offset + fieldLen, nil
}

func (x *xCliHello) parseCipherSuites(buffer []byte) (uint32, error) {

	offset := uint32(offsetCipherSuitesLen)
	fieldLen := binary.BigEndian.Uint16(buffer[:2])
	if len(buffer) < int(fieldLen) {
		return 0, fmt.Errorf("CipherSuites field is too small")
	}

	if fieldLen%2 != 0 {
		return 0, fmt.Errorf("CipherSuites field is not a multiple of 2")
	}

	fl := fieldLen / 2
	x.helloMsg.CipherSuites = make([]uint16, fl)
	for i := uint16(0); i < fl; i++ {
		x.helloMsg.CipherSuites[i] = binary.BigEndian.Uint16(
			buffer[offset : offset+2])
		offset += 2
	}

	x.lg.Trace("Field[CipherSuites]: ",
		mx.AlgosToName(0xFFFF, x.helloMsg.CipherSuites))
	return offset, nil
}

// Parse and store only supported extensions data
func (x *xCliHello) parseExtensions(buffer []byte) {

	if len(buffer) < 2 {
		return
	}

	offset := 0
	extLen := binary.BigEndian.Uint16(buffer[:2])
	if len(buffer) < int(extLen) {
		return
	}

	offset += 2
	for offset < int(extLen) {
		//extt := binary.BigEndian.Uint16(buffer[offset : offset+2])
		exttLen := binary.BigEndian.Uint16(buffer[offset+2 : offset+4])
		offset += 2 + 2
		/*if ex.SupportedExtensions[extt] != "" {
			x.loadExtensionsData(buffer[offset:], extt, exttLen)
		}*/

		offset += int(exttLen)
	}
}

// Store extension data in the hello message
/*func (x *xCliHello) loadExtensionsData(buffer []byte, ext, extLen uint16) {

	fn := x.exts.GetExtLoadFn(ext)
	if fn == nil {
		return
	}

	data, err := fn(buffer, int(extLen))
	if err != nil {
		x.lg.Errorf("data load(%v): %v", ex.SupportedExtensions[ext], err)
		return
	}

	x.helloMsg.Extensions[ext] = data
	x.lg.Trace(fmt.Sprintf("Field[Extension SignAlgo(0x000D)]: %v",
		x.exts.SignAlgo.PrintRaw(buffer[:int(extLen)])))
}*/

// Load data for every extension
// By the way, very bad design to handle extensions
/*switch extt {
case 0x000D:
	data, err := x.mods.SignAlgo.LoadData(
		buffer[offset : offset+int(exttLen)])
	if err != nil {
		x.lg.Errorf("data load(%v): %v", x.mods.SignAlgo.Name(), err)
		continue
	}

	x.helloMsg.Extensions[extt] = data
	x.lg.Trace(fmt.Sprintf("Field[Extension SignAlgo(0x000D)]: %v",
		x.mods.SignAlgo.PrintRaw(buffer[offset:offset+int(exttLen)])))
}*/
