package tester

import (
	"net"
	"testing"
	"time"
	"tlesio/tlssl"
	"tlesio/tlssl/handshake"
)

type xFakeConn struct {
	net.Conn
	counter int
}

func TestStageFinishedClient(t *testing.T) {

	var newCtx handshake.AllContexts

	lg := testLogger()
	newCtx.Hctx = testCtxHandshake(&testHandshakeCtxData{
		comms:    &xFakeConn{},
		stage:    handshake.STAGE_SERVERHELLODONE,
		expected: handshake.CLIENTKEYEXCHANGE | handshake.CHANGECIPHERSPEC,
		order: []int{handshake.CLIENTHELLO,
			handshake.SERVERHELLO,
			handshake.CERTIFICATE,
			handshake.SERVERHELLODONE},
	})

	if newCtx.Hctx == nil {
		t.Errorf("Error: %v", "nil handshake context")
		return
	}

	newCtx.Tctx = &tlssl.TLSContext{
		Lg: lg,
	}

	transit := handshake.NewTransition(&newCtx)
	lg.Info("Starting test")
	if err := transit.Handle(); err != nil {
		t.Errorf("Error: %v", err)
	}
}

func (x *xFakeConn) Read(b []byte) (int, error) {

	if x.counter > 0 {
		pkt := clientKeyExchange()
		time.Sleep(2 * time.Second)
		copy(b, pkt)
		return len(pkt), nil
	}

	x.counter++
	buff1 := changeCipherSpec()
	copy(b, buff1)
	return len(buff1), nil
}

func changeCipherSpec() []byte {
	return []byte{0x14, 0x03, 0x03, 0x00, 0x01, 0x01}
}

func clientKeyExchange() []byte {

	// PreMasterSecret 48 bytes
	return []byte{
		0x16, 0x03, 0x03, 0x00, 0xA4, 0x01, 0x00, 0x00, 0xA0, 0x03, 0x03, 0x5B, 0x57, 0x76, 0xA0, 0x98,
		0x72, 0x6C, 0x8B, 0x6C, 0xC0, 0x26, 0x51, 0x84, 0x5B, 0xE3, 0x1D, 0xF0, 0x8B, 0x7F, 0x33, 0x60,
		0x65, 0xE3, 0x48, 0x63, 0xAB, 0xBC, 0xA9, 0xF4, 0x99, 0x73, 0x8C, 0xE4, 0x41, 0x9A, 0xF1, 0x52,
		0xDC, 0x61, 0x04, 0x1B, 0xB9, 0x7A, 0x70, 0x63, 0x82, 0x29, 0x4F, 0xB7, 0x9D, 0x64, 0x0A, 0x23,
		0x6D, 0x0E, 0x10, 0xB2, 0xA7, 0xD5, 0x55, 0x32, 0x1C, 0xE5, 0x9E, 0x06, 0x0A, 0x8F, 0xF3, 0x3C,
		0x33, 0x33, 0x7E, 0x99, 0x44, 0xF6, 0x59, 0x2F, 0x6E, 0xDC, 0xA1, 0x56, 0x24, 0x1F, 0x1F, 0x93,
		0xA4, 0x28, 0x97, 0x2D, 0xA5, 0xB3, 0x74, 0x74, 0x70, 0xC3, 0xB2, 0xB7, 0x56, 0x44, 0x69, 0xE6,
	}
}
