package tlss

import (
	"fmt"

	"github.com/sirupsen/logrus"
)

// ClientHello message structure in TLS 1.2
// | Field            | Size (bytes) | Description                                              |
// |------------------|--------------|----------------------------------------------------------|
// | Version          | 2 bytes      | TLS version (e.g., 0x0303 for TLS 1.2)                   |
// | Random           | 32 bytes     | Random number generated by the client                    |
// | Session ID       | Variable     | Client session ID, can be empty                          |
// | Cipher Suites    | Variable     | List of cipher suites supported by the client            |
// | Compression Methods | Variable   | Compression methods supported by the client             |
// | Extensions       | Variable     | Extensions (optional)                                    |
// |--------------------------------------------------------------------------------------------|

var (
	offsetVersion uint32 = 2
	offsetRandom  uint32 = 32
)

// Compresion Methods will be ignored
// Using byte arrays instead of "uint*" to avoid endianess issues
type clientHelloMsg struct {
	version      [2]byte
	random       [32]byte
	sessionId    []byte
	cipherSuites []uint16
	extensions   []byte
}

type clientHello struct {
	lg       *logrus.Logger
	helloMsg clientHelloMsg
}

func newClientHello(buffer []byte, lg *logrus.Logger) *clientHelloMsg {

	var ch clientHello
	var offset uint32 = 0

	if lg == nil {
		return nil
	}

	if buffer == nil || len(buffer) < 38 {
		lg.Error("ClientHello buffer is nil or too small")
		return nil
	}

	ch.lg = lg
	offset = ch.parseVersion(buffer)
	offset = ch.parseRandom(buffer[offset:])
	ch.parseSessionID(buffer[offset:])
	return nil
}

func (ch *clientHello) parseVersion(buffer []byte) uint32 {

	ch.helloMsg.version = [2]byte{buffer[0], buffer[1]}
	ch.lg.Debug("Field[Version]: ", prettyPrint(ch.helloMsg.version[:]))
	return offsetVersion
}

func (ch *clientHello) parseRandom(buffer []byte) uint32 {

	copy(ch.helloMsg.random[:], buffer[:offsetRandom])
	ch.lg.Debug("Field[Random]: ", prettyPrint(ch.helloMsg.random[:]))
	return offsetRandom
}

func (ch *clientHello) parseSessionID(buffer []byte) uint32 {

	sessionIDLen := uint32(buffer[0])
	offset := uint32(1)
	ch.helloMsg.sessionId = make([]byte, sessionIDLen)
	copy(ch.helloMsg.sessionId, buffer[offset:offset+sessionIDLen])
	ch.lg.Debug("Field[SessionID]: ", prettyPrint(ch.helloMsg.sessionId))
	fmt.Println("REVISAR SESSION ID")
	return offset + sessionIDLen
}

// Print a byte array in a 'pretty' format
func prettyPrint(buffer []byte) string {

	var pretty string

	for i, b := range buffer {
		pretty += fmt.Sprintf("%02x ", b)
		if (i+1)%16 == 0 && i+1 != len(buffer) {
			pretty += "\n"
		}
	}

	return pretty
}
